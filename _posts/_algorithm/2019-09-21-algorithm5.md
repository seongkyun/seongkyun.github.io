---
layout: post
title: 알고리즘 기초-그래프의 탐색 (DFS, BFS)
category: algorithm
tags: [algorithm]
comments: true
---

# 알고리즘 기초-그래프의 탐색 (DFS, BFS)
- DFS, BFS의 목적?
  - 정점 탐색용.
  - __임의의 시작점 x에서 시작해서 모든 정점을 1번씩 방문하는것이 주요 목적!__
- DFS: 깊이 우선 탐색
  - 스택을 사용함
  - 한 시작점에서 깊이 방향으로 갈 수 있을때까지 계속 진행
  - 끝에 도달하면 다시 다른 방문 가능한 노드가 있는 지점으로 다시 돌아와서, 다른 노드를 모두 방문
  - 방문 가능한 노드가 없어지면 다시 처음 시작 노드로 돌아온다.
- BFS: 너비 우선 탐색
  - 큐를 사용함
  - 한 정점에서 갈 수 있는걸 동시에 다 접근하며 퍼져나가는것.
  - 한 노드에서 방문 가능한 노드를 고르고(순서 없으나 작은걸 우선 고름) 해당 노드에서 방문 가능한걸 또 고려
  - 방문 가능한 노드 없을때까지 반복
- 두 방법은 순서의 차이가 있음

## 깊이 우선 탐색 (DFS)

<center>
<figure>
<img src="/assets/post_img/algorithm/2019-09-22-algorithm/fig3.PNG" alt="views">
<figcaption> </figcaption>
</figure>
</center>

- 위와 같은 그래프가 있을 때
- 스택을 이용해서 갈 수 있는만큼 최대한 많이 가고
- 갈 수 없으면 이전 정점(노드)으로 돌아간다.
- 전체 노드에 대해 실제 한번씩 방문했는지를 check하는 노드 갯수 길이만큼 check 배열을 만들고
  - 위 경우, check[1] ~ check[6] 의 길이 6짜리 배열이 있다고 하면

- 1번 노드에서 시작하는 경우
  - 현재 노드 값 1을 stack에 넣고, check[1] = 1 로 변경
  - 현재 정점: 1
  - 순서: 1
  - 스택: 1
- 다음 노드는 순서 상관 없지만 숫자 작은 2를 방문할 경우
  - 현재 노드 값 2를 stack에 넣고, check[2] = 1 로 변경
  - 현재 정점: 2
  - 순서: 1 2
  - 스택: 1 2
- 다음 노드는 작은 숫자인 3을 방문하면
  - 현재 노드 값 3을 stack에 넣고, check[3] = 1 로 변경
  - 현재 정점: 3
  - 순서: 1 2 3
  - 스택: 1 2 3
- 다음 노드는 check를 봤을 때, 2와 4가 가능하지만 check[2]가 1이므로 check[4] = 0인 4를 방문
  - 현재 노드 값 4를 stack에 넣고, check[4] = 1 로 변경
  - 현재 정점: 4
  - 순서: 1 2 3 4
  - 스택: 1 2 3 4
- 다음 노드는 5와 6이 가능하지만 숫자가 작은 5를 방문
  - 현재 노드 값 5를 stack에 넣고, check[5] = 1 로 변경
  - 현재 정점: 5
  - 순서: 1 2 3 4 5
  - 스택: 1 2 3 4 5
- 다음 노드에 가능한 경우는 1, 2, 4 이지만, check 값들이 모두 1이므로 가능한 경우가 없다. 이런 경우 stack 마지막 값을 pop 하여 꺼내고 해당 스택 마지막 값(위치: 4)에서 가능한 경우를 다시 고려한다
- 5에서 가능한 경우가 없으므로 4 위치로 돌아온다.
  - 5를 stack에서 pop하여 꺼낸다
  - 현재 정점: 4
  - 순서: 1 2 3 4 5
  - 스택: 1 2 3 4
- 4에서 가능한 나머지 경우인 6에 접근한다(check[6] = 0 이므로)
  - 현재 노드 값인 6을 stack에 넣고, check[6] = 1 로 변경
  - 현재 정점: 6
  - 순서: 1 2 3 4 5 6
  - 스택: 1 2 3 4 6
- 6에서 연결된 노드의 check 값이 모두 1이므로 stack에서 마지막 값을 pop하고 이전 노드인 4로 돌아간다.
  - 현재 정점: 4
  - 순서: 1 2 3 4 5 6
  - 스택: 1 2 3 4
- 마찬가지로, 연결된 노드의 check 값이 모두 1이므로 stack 값을 pop하고 해당 노드 3으로 돌아간다.
  - 현재 정점: 3
  - 순서: 1 2 3 4 5 6
  - 스택: 1 2 3
- 이 과정을 반복해서 1까지 돌아가면
  - 현재 정점: 1
  - 순서: 1 2 3 4 5 6
  - 스택: 1
- 1에서 마찬가지로 연결된 5와 2의 check이 모두 1이므로, stack에 값을 pop한다.
- stack이 비게 되는 경우 탐색이 종료됨을 의미한다.

### 인접 행렬의 깊이 우선 탐색(DFS) 구현
- 재귀 호출을 이용해 구현한다.
  - dfs(x)는 현재 x 노드에 방문했음을 의미한다.
  - 전체 정점의 개수를 V 라고 정의한다.

```c
void dfs (int x)
{
  check[x] = true; // 현재 x 노드에 방문했으므로 check를 1로
  printf("%d ", x); // 현재 노드 값을 출력 (필요없음)
  for (int i=1; i<=n; i++) // 노드(i) 1번부터 마지막 노드 n번까지 돌면서
  {
    if (a[x][i] == 1 && check[1] == false) // x에서 i노드로 간선이 존재하고, check가 false로 방문한 적이 없으면
    {
      dfs(i); // i 노드를 방문한다.
    }
  }
}
```

- 위 과정의 시간의 복잡도는 $O(V^2)$ 이다.
  - DFS의 목적은 모든 정점을 1번씩 방문하는것이다.
  - 전체 정점의 개수에 대해 모두 V 만큼 방문해야 하므로 dfs(x)는 V번 호출된다.
  - dfs(x) 자체의 시간복잡도 x for문에서 V번 호출이므로, 빅-오는 $O(V^2)$가 된다.

### 인접 리스트의 깊이 우선 탐색(DFS) 구현
- 재귀 호출을 이용해 구현한다.
  - 동일하게 dfs(x)는 현재 x 노드에 방문함을 의미한다.
  - 전체 정점의 개수는 동일하게 V, 간선의 개수는 E 개다.

```c
void dfs (int x)
{
  check[x] = true; // 현재 노드 x에 방문했으므로
  printf("%d ", x); // 현재 노드 값 출력
  // 인접 리스트가 저장된 a의 x번째 항에는 연결된 노드 값들이 저장되어있으므로, for문은 x에서 연결된 노드 개수인 a[x].size() 만큼 돈다.
  for (int i=0; i<a[x].size(); i++)
  {
    int y = a[x][i]; // y에는 x에서 연결된 i 번째 노드 값들이 저장된다.(다음에 방문할 노드 값 y)
    // 위 그림의 경우, a[0] = 1이라면 a[0][0] = 2, a[0][1] = 5가 저장되어 있다.
    if (check[y] == false) // 방문한 적이 없는 경우
    {
      dfs(y) // 방문
    }
  }
}
```

- 인접 리스트의 경우, for 문 안의 if 문에서는 방문여부만 따진다.
  - 이는 존재하지 않는 간선정보까지 0으로 저장하는 인접 행렬과 다르게 인접 리스트는 존재하는 간선정보만 저장하게 되므로 해당 간선의 존재여부를 따로 따지지 않아도 되기 때문이다.
  
- 위 과정의 시간 복잡도는 $O(V+E)$
  - dfs(x)는 V번 호출된다. 하지만 dfs(x)는 간선의 개수인 E의 복잡도만 갖는다.
    - 인접 리스트는 존재하는 간선의 개수만큼만 참조되므로!

## 너비 우선 탐색 (BFS)
- DFS가 스택을 사용하는것과 다르게, 큐(Queue)를 이용해 지금 위치에서 갈 수 있는 모든 노드값을 큐에 넣는 방식으로 참조된다.
- 큐에 넣을 때! 반드시 방문했다고 체크해야 한다.

<center>
<figure>
<img src="/assets/post_img/algorithm/2019-09-22-algorithm/fig3.PNG" alt="views">
<figcaption> </figcaption>
</figure>
</center>

- __BFS는 갈 수 있는데를 우선 큐에 넣고 연산을 진행한다.__
  - 큐에 넣는 시점에 방문했다고 체크해야 한다.
- 만약 1에 방문(시작) 하고, 2와 5를 큐에 넣고, 1을 check 하고, 2를 방문하고 check 하고, 2와 5를 큐에 넣는다면?
  - 현재 정점: 1
  - 순서: 1 2 5
  - 큐: 2 5
  - 위 상태에서 5는 방문하지 않았지만 미리 큐에 존재하는 상태가 된다.
  - 이럴 경우 큐 사용에 오류가 발생한다! (아래 그림 참조)

<center>
<figure>
<img src="/assets/post_img/algorithm/2019-09-21-algorithm5/fig1.PNG" alt="views">
<figcaption> </figcaption>
</figure>
</center>

- 그래프에서 시작 정점을 1이라고 한다면
  - 현재 시작 정점 값을 큐에 넣고 check[1] = 1 로 초기화
  - 현재 정점: 1
  - 순서: 1
  - 큐: 1
  - 다음으로, 방문 가능한 2와 5 노드 값을 큐에 넣고, 넣음과 동시에 check[2]와 check[5] 를 1로 초기화
    - 현재 정점: 1
    - 순서: 1 2 5
    - 큐: 1 2 5
- 다음으로, 2번 노드를 방문하고 동시에 방금 노드였던 1값을 큐에서 꺼냄 (큐 값을 꺼내고, 큐 맨 앞의 노드로 이동)
  - 현재 정점: 2
  - 순서: 1 2 5
  - 큐: 2 5
  - 다음으로, 방문 가능한 3 노드 값을 큐에 넣고, 넣음과 동시에 check[3] 을 1로 초기화
    - 현재 정점: 2
    - 순서: 1 2 5 3
    - 큐: 2 5 3
- 다음으로, 5번 노드를 방문하고 동시에 방금 노드였던 2 값을 큐에서 꺼냄 (큐 값을 꺼내고, 그 다음 맨 앞의 노드를 참조)
  - 현재 정점: 5
  - 순서: 1 2 5 3
  - 큐: 5 3
  - 다음으로, 방문 가능한 4 노드 값을 큐에 넣고, 넣음과 동시에 check[4] 를 1로 초기화
    - 현재 정점: 5
    - 순서: 1 2 5 3 4
    - 큐: 5 3 4
- 다음으로, 큐에서 5를 꺼내면 3번 노드이므로 3번 노드로 이동
  - 현재 정점: 3
  - 순서: 1 2 5 3 4
  - 큐: 3 4
- 가능한 경우가 없으므로 (주변 모두 checked), 3을 꺼내고 4번 노드로 이동
  - 현재 정점: 4
  - 순서: 1 2 5 3 4
  - 큐: 4
  - 다음으로, 4번 노드에서 방문 가능한 6번 값을 큐에 넣고, check[6]을 1로 초기화
    - 현재 정점: 4
    - 순사: 1 2 5 3 4 6
    - 큐: 4 6
- 큐에서 4를 꺼낸 후 마지막 남는 6번 노드로 이동
  - 현재 정점: 6
  - 순저: 1 2 5 3 4 6
  - 큐: 6
- 가능한 경우가 없으므로, 큐에서 마지막 값인 6을 거냄
  - 현재 정점: 6
  - 순저: 1 2 5 3 4 6
  - 큐: 
- 큐가 비게 되므로, 최종적으로 탐색이 완료 됨
  
- 참고: https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html
  
### 인접 행렬을 이용한 너비 우선 탐색(BFS) 코드 구현
- BFS의 구현은 큐를 이용해 구현한다.
- DFS와 다르게 재귀적으로 구성이 불가능하다!
  - 큐가 빌 동안 while문을 돌면 됨

```c
queue<int> q; // 큐를 할당
check[1] = true; // 첫 번째 노드를 방문함을 표시
q.push(1); // 큐에 시작점인 1번 노드 쌓기
while (!q.empty()) // 큐가 비지 않았을 동안
{
  int x = q.front(); // 현재 방문 노드를 x에 저장하고
  q.pop(); // 방금 반횐된 노드를 삭제(큐이므로 앞에서)
  printf("%d ", x); // 현재 노드 값을 출력
  for (int i=1; i<=n; i++) // 1부터 인접행렬 주변 정점의 개수를 파악하기 위해
  {
    if (a[x][i] == 1 && check[i] == false) // 만약 x(현재노드)와 i(다음노드)가 연결되어있고 방문한적 없다면
    {
      check[i] = true; // 해당 노드를 방문
      q.push(i); // 큐에 해당 노드 값을 저장
      // 순서상 방문 먼저 하고 check를 함. (순서 중요!)
      // 이는 큐의 중복된 정점 지정을 막아주기 위함임.
    }
  }
}
```

### 인접 리스트를 이용한 너비 우선 탐색(BFS) 코드 구현
- 동일하게 큐를 이용해서 구현

```c
queue<int> q;
check[1] = true; q.push(1); // 1번 노드에서 시작한다 가정하고, 해당 노드를 큐에 넣음
while (!q.empty())  // 큐가 비지 않을 동안 돌면서
{
  int x = q.front(); q.pop(); // x에 현재 노드 값을 넣고, 삭제
  printf("%d ", x); // 현재 노드 값 출력
  for (int i=0; i<a[x].size(); i++) // a[현재노드].size()는 현재 노드와 연결된 노드 갯수가 저장됨 (즉, 모든 노드 참조)
  {
    int y = a[x][i]; // 다음 참조할 노드를 y라고 하고
    if (check[y] == false) // 참조되지 않았다면
    {
      check[y] = true; q.push(y); // y를 check 하고 큐에 노드 값을 넣음(순서!ckeck->qush)
    }
  }
}
```

### BFS의 시간 복잡도
- 목적이 DFS, BFS가 모두 같으므로 시간복잡도도 동일함
  - 둘다모든 정점을 한번씩 방문
  - DFS: 모든 정점이 stack에 한번씩 들어갔다 나오고
  - BFS: 모든 정점이 queue에 한번씩 들어갔다 나오고
  - 둘 다 참조가 동일하므로 복잡도가 동일

### 1260 DFS와 BFS
- 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 문제
- https://www.acmicpc.net/problem/1260

```c
#pragma warning(disable:4996)
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;
vector<int> nodes[1001]; // 노드 저장
bool check[1001]; // check

void dfs(int x)
{
	check[x] = true; // 현재 노드를 참조
	printf("%d ", x); // 결과 출력
	for (int i = 0; i < int(nodes[x].size()); i++) // 해당 노드와 연결된 노드 중
	{
		int y = nodes[x][i]; // 다음 노드 값을 y로 두고
		if (check[y] == false) dfs(y); // 만약 y가 방문하지 않았다면 재귀적으로 dfs(y) 호출
	}
}

void bfs(int x)
{
	queue<int> q;
	check[x] = true; // 현재 노드를 참조
	q.push(x); // 참조 된 노드를 큐에 넣고
	while (!q.empty()) // 큐가 빌 때까지
	{
		int node = q.front(); // 현재 노드를 node에 저장 후
		q.pop(); // 큐에서 현제 노드 제거
		printf("%d ", node); // 현재 노드를 출력
		for (int i = 0; i < int(nodes[node].size()); i++) // 현제 노드에서
		{
			int y = nodes[node][i]; // 다음 노드를 y로 선택 후
			if (check[y] == false) // 방문하지 않았다면
			{
				check[y] = true; // 방문한거로 체크하고
				q.push(y); // 큐에 집어넣는다.
			}
		}
	}
}

int main()
{
	int N, M, start; / /순서대로 정점의 개수, 노드의 개수, 시작점을 입력
	scanf("%d %d %d", &N, &M, &start);

	for (int i = 0; i < M; i++)
	{
		int a, b;
		scanf("%d %d", &a, &b); // 순서대로 간선이 연결하는 두 정점의 번호가 주어짐 (서로 연결됨)
		nodes[a].push_back(b); // a번 노드에 b가 연결되어있으므로, nodes[a]에 b를 추가
		nodes[b].push_back(a); // b번 노드에 a가 연결되어있으므로 nodes[b]에 a 추가
	}
	for (int i = 1; i <= N; i++)
	{
		sort(nodes[i].begin(), nodes[i].end()); // 정점 번호가 작은거를 먼저 방문하므로 모두 정렬
	}
	dfs(start);
	printf("\n");
	for (int i = 0; i < 1001; i++)
		check[i] = false; // check 초기화
	bfs(start);
	printf("\n");
	
	system("pause");
	return 0;
}
```
